<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Causal Perturbation Liveness Prototype</title>
  <style>
    :root {
      --bg: #f4f2ec;
      --ink: #1c1d1f;
      --muted: #5a606b;
      --panel: #ffffff;
      --line: #d6d8de;
      --accent: #0f766e;
      --accent-2: #f59e0b;
      --good: #0f9d58;
      --warn: #b45309;
      --bad: #b91c1c;
      --mono: "SFMono-Regular", Menlo, Consolas, "Liberation Mono", monospace;
      --sans: "Avenir Next", "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: var(--sans);
      color: var(--ink);
      background:
        radial-gradient(circle at 10% 10%, rgba(15, 118, 110, 0.12), transparent 35%),
        radial-gradient(circle at 85% 15%, rgba(245, 158, 11, 0.12), transparent 38%),
        linear-gradient(145deg, #f9f7f3, var(--bg));
      min-height: 100vh;
      padding: 18px;
    }

    .layout {
      max-width: 1180px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 14px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 8px 32px rgba(20, 24, 35, 0.06);
    }

    .left {
      padding: 14px;
      display: grid;
      gap: 10px;
    }

    .topline {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }

    h1 {
      margin: 0;
      font-size: 1.16rem;
      line-height: 1.2;
      letter-spacing: 0.01em;
    }

    .small {
      font-size: 0.84rem;
      color: var(--muted);
      margin: 0;
      line-height: 1.45;
    }

    .chip {
      font-family: var(--mono);
      font-size: 0.72rem;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--muted);
      background: #fbfbfc;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    button {
      border: 1px solid var(--line);
      background: #fff;
      color: var(--ink);
      border-radius: 10px;
      font: inherit;
      font-weight: 600;
      padding: 9px 12px;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.1s ease, border-color 0.1s ease;
    }

    button:hover {
      border-color: #a9afb8;
      box-shadow: 0 3px 10px rgba(12, 18, 32, 0.08);
    }

    button:active {
      transform: translateY(1px);
    }

    button.primary {
      border-color: #0b5f58;
      background: linear-gradient(140deg, #0f766e, #0b615a);
      color: #fff;
    }

    button.ghost {
      background: #fcfcfd;
    }

    button:disabled {
      opacity: 0.55;
      cursor: default;
      box-shadow: none;
    }

    .status {
      font-size: 0.82rem;
      color: var(--muted);
      font-family: var(--mono);
    }

    .arena-wrap {
      border-radius: 12px;
      border: 1px solid var(--line);
      overflow: hidden;
      background: linear-gradient(180deg, #f7f8fa, #eff1f5);
      min-height: 420px;
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: 420px;
      touch-action: none;
      cursor: crosshair;
    }

    .hud {
      position: absolute;
      left: 10px;
      right: 10px;
      top: 10px;
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      pointer-events: none;
    }

    .hud-box {
      border: 1px solid rgba(28, 29, 31, 0.12);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.75);
      backdrop-filter: blur(1.5px);
      padding: 6px 8px;
    }

    .hud-label {
      font-size: 0.64rem;
      text-transform: uppercase;
      color: var(--muted);
      letter-spacing: 0.08em;
      margin-bottom: 2px;
      font-family: var(--mono);
    }

    .hud-value {
      font-weight: 700;
      font-size: 0.9rem;
      font-family: var(--mono);
    }

    .progress {
      height: 6px;
      border-radius: 999px;
      overflow: hidden;
      background: #e9edf3;
      border: 1px solid #d9dee8;
    }

    .progress > div {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, #0f766e, #f59e0b);
      transition: width 0.08s linear;
    }

    .right {
      padding: 14px;
      display: grid;
      gap: 10px;
      align-content: start;
    }

    .score {
      border-radius: 10px;
      border: 1px solid var(--line);
      padding: 10px;
      background: #fbfbfc;
    }

    .score-top {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 4px;
    }

    .score-num {
      font-size: 1.9rem;
      font-family: var(--mono);
      font-weight: 700;
      line-height: 1;
    }

    .verdict {
      font-weight: 700;
      font-size: 0.92rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    th, td {
      text-align: left;
      border-bottom: 1px solid #eceff4;
      padding: 6px 2px;
      vertical-align: top;
    }

    th {
      color: var(--muted);
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      font-family: var(--mono);
      font-weight: 600;
    }

    .mono {
      font-family: var(--mono);
      font-size: 0.74rem;
      white-space: pre-wrap;
      background: #f7f8fb;
      border: 1px solid #e3e7ef;
      border-radius: 10px;
      padding: 8px;
      max-height: 210px;
      overflow: auto;
      color: #2f3947;
    }

    .legend {
      display: grid;
      gap: 6px;
      font-size: 0.78rem;
      color: #3f4650;
      padding: 8px;
      border: 1px dashed #d4d8e0;
      border-radius: 10px;
      background: #fafbfc;
    }

    .legend b {
      color: #1d242e;
    }

    .footnote {
      font-size: 0.74rem;
      color: var(--muted);
      line-height: 1.4;
    }

    @media (max-width: 1020px) {
      .layout {
        grid-template-columns: 1fr;
      }

      canvas {
        height: 360px;
      }

      .arena-wrap {
        min-height: 360px;
      }

      .hud {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
  </style>
</head>
<body>
  <div class="layout">
    <section class="panel left">
      <div class="topline">
        <h1>Causal Perturbation Liveness (research prototype)</h1>
        <div class="chip" id="seedChip">seed: -</div>
      </div>
      <p class="small">
        This test deliberately injects tiny unpredictable target perturbations and scores <b>causal motor recovery</b>.
        It avoids a heavy data flywheel by using physiology-informed checks instead of a black-box classifier.
      </p>

      <div class="controls">
        <button id="startBtn" class="primary">Start 22s test</button>
        <button id="resetBtn" class="ghost">Reset</button>
        <button id="exportBtn" class="ghost" disabled>Export session JSON</button>
        <span class="status" id="statusLine">idle</span>
        <span class="status" id="serverLine">backend: local-only</span>
      </div>

      <div class="progress" aria-hidden="true"><div id="progressFill"></div></div>

      <div class="arena-wrap">
        <canvas id="arena" aria-label="Liveness challenge arena"></canvas>
        <div class="hud">
          <div class="hud-box">
            <div class="hud-label">Time</div>
            <div class="hud-value" id="hudTime">0.0s</div>
          </div>
          <div class="hud-box">
            <div class="hud-label">Perturbations</div>
            <div class="hud-value" id="hudPerturb">0</div>
          </div>
          <div class="hud-box">
            <div class="hud-label">Inside Target</div>
            <div class="hud-value" id="hudInside">0%</div>
          </div>
          <div class="hud-box">
            <div class="hud-label">Pointer Hz</div>
            <div class="hud-value" id="hudHz">0</div>
          </div>
        </div>
      </div>

      <div class="legend">
        <div><b>What to do:</b> keep the pointer inside the moving teal target. Recover quickly when it jitters.</div>
        <div><b>Why this works:</b> scripted paths can mimic style, but causal correction latency and gain under hidden perturbation are harder to fake in real time.</div>
      </div>
    </section>

    <aside class="panel right">
      <div class="score">
        <div class="score-top">
          <div class="score-num" id="scoreNum">--</div>
          <div class="verdict" id="verdictLine">No run yet</div>
        </div>
        <p class="small" id="summaryLine">Run the test to compute an explainable score.</p>
      </div>

      <table>
        <thead>
          <tr>
            <th>Signal</th>
            <th>Value</th>
            <th>Contribution</th>
          </tr>
        </thead>
        <tbody id="metricsBody">
          <tr><td colspan="3" class="small">No metrics yet.</td></tr>
        </tbody>
      </table>

      <div>
        <div class="small" style="margin-bottom:6px;">Event log</div>
        <div class="mono" id="eventLog">Waiting for first run.</div>
      </div>

      <div class="footnote">
        Use this as one signal in a layered defense. Do not block users solely from one short challenge.
      </div>
    </aside>
  </div>

  <script>
    (function () {
      const CONFIG = {
        durationMs: 22000,
        sampleHzCap: 120,
        canvasPad: 34,
        perturbation: {
          minGapMs: 1050,
          maxGapMs: 2150,
          minShiftPx: 18,
          maxShiftPx: 44,
          decayMs: 760
        },
        difficulty: [
          { start: 0, end: 7200, speed: 0.42, radius: 33, label: "low" },
          { start: 7200, end: 14500, speed: 0.62, radius: 27, label: "mid" },
          { start: 14500, end: 22000, speed: 0.88, radius: 21, label: "high" }
        ]
      };

      const arena = document.getElementById("arena");
      const ctx = arena.getContext("2d", { alpha: false });

      const statusLine = document.getElementById("statusLine");
      const serverLine = document.getElementById("serverLine");
      const seedChip = document.getElementById("seedChip");
      const progressFill = document.getElementById("progressFill");

      const hudTime = document.getElementById("hudTime");
      const hudPerturb = document.getElementById("hudPerturb");
      const hudInside = document.getElementById("hudInside");
      const hudHz = document.getElementById("hudHz");

      const startBtn = document.getElementById("startBtn");
      const resetBtn = document.getElementById("resetBtn");
      const exportBtn = document.getElementById("exportBtn");

      const scoreNum = document.getElementById("scoreNum");
      const verdictLine = document.getElementById("verdictLine");
      const summaryLine = document.getElementById("summaryLine");
      const metricsBody = document.getElementById("metricsBody");
      const eventLog = document.getElementById("eventLog");

      const state = {
        phase: "idle",
        seed: 0,
        rng: null,
        startMs: 0,
        elapsedMs: 0,
        frameId: 0,
        nextPerturbAt: Infinity,
        currentImpulse: null,
        lastFrameMs: 0,
        bounds: { w: 0, h: 0 },
        pointer: { x: 0, y: 0, has: false, active: false },
        target: { x: 0, y: 0, radius: 30, seg: "low" },
        samples: [],
        frameSeries: [],
        perturbations: [],
        corrections: [],
        insideMs: 0,
        totalMs: 0,
        challenge: { mode: "local", id: null, token: null, issuedAt: 0, expiresAt: 0 },
        verification: null,
        finalReport: null
      };

      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      function mulberry32(seed) {
        let t = seed >>> 0;
        return function () {
          t += 0x6d2b79f5;
          let r = Math.imul(t ^ (t >>> 15), 1 | t);
          r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
          return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
        };
      }

      function makeSeed() {
        const arr = new Uint32Array(2);
        crypto.getRandomValues(arr);
        return (arr[0] ^ (arr[1] << 1)) >>> 0;
      }

      function mean(arr) {
        if (!arr.length) return 0;
        let s = 0;
        for (const v of arr) s += v;
        return s / arr.length;
      }

      function percentile(arr, p) {
        if (!arr.length) return 0;
        const sorted = [...arr].sort((a, b) => a - b);
        const idx = clamp((sorted.length - 1) * p, 0, sorted.length - 1);
        const lo = Math.floor(idx);
        const hi = Math.ceil(idx);
        if (lo === hi) return sorted[lo];
        const t = idx - lo;
        return sorted[lo] * (1 - t) + sorted[hi] * t;
      }

      function format(n, digits = 1) {
        if (!Number.isFinite(n)) return "-";
        return n.toFixed(digits);
      }

      function currentDifficulty(t) {
        for (const seg of CONFIG.difficulty) {
          if (t >= seg.start && t < seg.end) return seg;
        }
        return CONFIG.difficulty[CONFIG.difficulty.length - 1];
      }

      function updateCanvasSize() {
        const rect = arena.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        arena.width = Math.max(1, Math.floor(rect.width * dpr));
        arena.height = Math.max(1, Math.floor(rect.height * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        state.bounds.w = rect.width;
        state.bounds.h = rect.height;
      }

      function resetStateForRun() {
        if (state.frameId) cancelAnimationFrame(state.frameId);
        state.phase = "idle";
        state.seed = 0;
        state.rng = null;
        state.startMs = 0;
        state.elapsedMs = 0;
        state.frameId = 0;
        state.nextPerturbAt = Infinity;
        state.currentImpulse = null;
        state.lastFrameMs = 0;

        state.pointer.x = state.bounds.w / 2;
        state.pointer.y = state.bounds.h / 2;
        state.pointer.has = false;
        state.pointer.active = false;

        state.target.x = state.bounds.w / 2;
        state.target.y = state.bounds.h / 2;
        state.target.radius = 30;
        state.target.seg = "low";

        state.samples = [];
        state.frameSeries = [];
        state.perturbations = [];
        state.corrections = [];
        state.insideMs = 0;
        state.totalMs = 0;
        state.challenge = { mode: "local", id: null, token: null, issuedAt: 0, expiresAt: 0 };
        state.verification = null;
        state.finalReport = null;

        progressFill.style.width = "0%";
        seedChip.textContent = "seed: -";
        hudTime.textContent = "0.0s";
        hudPerturb.textContent = "0";
        hudInside.textContent = "0%";
        hudHz.textContent = "0";
        statusLine.textContent = "idle";
        serverLine.textContent = "backend: local-only";

        scoreNum.textContent = "--";
        scoreNum.style.color = "#1c1d1f";
        verdictLine.textContent = "No run yet";
        verdictLine.style.color = "#1c1d1f";
        summaryLine.textContent = "Run the test to compute an explainable score.";
        metricsBody.innerHTML = '<tr><td colspan="3" class="small">No metrics yet.</td></tr>';
        eventLog.textContent = "Waiting for first run.";

        exportBtn.disabled = true;
      }

      async function fetchChallenge() {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 2800);
        try {
          const res = await fetch("/api/challenge", {
            method: "GET",
            cache: "no-store",
            headers: { "Accept": "application/json" },
            signal: controller.signal
          });
          if (!res.ok) throw new Error("challenge_http_" + res.status);
          const data = await res.json();
          if (!data || !data.ok || !data.challenge || !data.token) throw new Error("challenge_shape");
          const c = data.challenge;
          if (!Number.isFinite(c.seed)) throw new Error("challenge_seed");
          return {
            mode: "server",
            id: c.challengeId,
            token: data.token,
            issuedAt: c.issuedAt,
            expiresAt: c.expiresAt,
            seed: c.seed >>> 0
          };
        } catch (_err) {
          return {
            mode: "local",
            id: null,
            token: null,
            issuedAt: Date.now(),
            expiresAt: Date.now() + 120000,
            seed: makeSeed()
          };
        } finally {
          clearTimeout(timeout);
        }
      }

      function compactReportForServer(report) {
        return {
          createdAt: report.createdAt,
          digest: report.digest,
          score: report.score,
          summary: report.summary,
          metrics: report.metrics.map(m => ({ key: m.key, value: m.value, contrib: m.contrib })),
          perturbations: report.perturbations,
          corrections: report.corrections
        };
      }

      async function verifyReportWithServer(report) {
        if (!state.challenge.token) {
          return { ok: false, verified: false, mode: "local", reason: "unsigned_local_challenge" };
        }
        try {
          const res = await fetch("/api/verify", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              token: state.challenge.token,
              report: compactReportForServer(report)
            })
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) {
            return {
              ok: false,
              verified: false,
              mode: "server",
              reason: data.error || ("verify_http_" + res.status)
            };
          }
          return {
            ok: !!data.ok,
            verified: !!data.verified,
            mode: "server",
            reason: data.reason || "ok",
            challengeId: data.challengeId || state.challenge.id,
            receipt: data.receipt || null
          };
        } catch (_err) {
          return { ok: false, verified: false, mode: "server", reason: "verify_network_error" };
        }
      }

      function scheduleNextPerturb(t) {
        const gap = lerp(CONFIG.perturbation.minGapMs, CONFIG.perturbation.maxGapMs, state.rng());
        state.nextPerturbAt = t + gap;
      }

      function injectPerturbation(t) {
        const angle = state.rng() * Math.PI * 2;
        const mag = lerp(CONFIG.perturbation.minShiftPx, CONFIG.perturbation.maxShiftPx, state.rng());
        const dx = Math.cos(angle) * mag;
        const dy = Math.sin(angle) * mag;
        const event = {
          id: state.perturbations.length + 1,
          t,
          dx,
          dy,
          mag,
          seg: state.target.seg
        };
        state.perturbations.push(event);
        state.currentImpulse = {
          eventId: event.id,
          dx,
          dy,
          start: t,
          decayMs: CONFIG.perturbation.decayMs
        };
      }

      function targetPositionAt(t) {
        const seg = currentDifficulty(t);
        const pad = CONFIG.canvasPad;
        const w = state.bounds.w;
        const h = state.bounds.h;
        const ax = Math.max(45, (w * 0.5) - pad);
        const ay = Math.max(45, (h * 0.5) - pad);

        const omega = 0.00115 * seg.speed;
        const xBase = w * 0.5 + Math.sin((t * omega * 1.22) + 0.7) * ax * 0.92;
        const yBase = h * 0.5 + Math.sin((t * omega * 1.81) + 1.9) * ay * 0.84;

        let ox = 0;
        let oy = 0;
        if (state.currentImpulse) {
          const age = t - state.currentImpulse.start;
          if (age >= 0 && age <= state.currentImpulse.decayMs) {
            const d = Math.exp(-age / 260);
            ox = state.currentImpulse.dx * d;
            oy = state.currentImpulse.dy * d;
          }
        }

        return {
          x: clamp(xBase + ox, pad, w - pad),
          y: clamp(yBase + oy, pad, h - pad),
          r: seg.radius,
          seg: seg.label
        };
      }

      function recordPointerSample(ts, x, y) {
        if (state.phase !== "running") return;
        const t = ts - state.startMs;
        if (t < 0 || t > CONFIG.durationMs + 100) return;

        const prev = state.samples[state.samples.length - 1];
        const minDt = 1000 / CONFIG.sampleHzCap;
        if (prev && (t - prev.t) < minDt) return;

        let vx = 0;
        let vy = 0;
        let speed = 0;
        if (prev) {
          const dt = (t - prev.t) / 1000;
          if (dt > 0) {
            vx = (x - prev.x) / dt;
            vy = (y - prev.y) / dt;
            speed = Math.hypot(vx, vy);
          }
        }

        state.samples.push({ t, x, y, vx, vy, speed });
      }

      function pointerPosition(e) {
        const rect = arena.getBoundingClientRect();
        return {
          x: clamp(e.clientX - rect.left, 0, rect.width),
          y: clamp(e.clientY - rect.top, 0, rect.height)
        };
      }

      function onPointerMove(e) {
        if (state.phase !== "running") return;
        if (e.cancelable) e.preventDefault();
        const p = pointerPosition(e);
        state.pointer.x = p.x;
        state.pointer.y = p.y;
        state.pointer.has = true;
        recordPointerSample(performance.now(), p.x, p.y);
      }

      function onPointerDown(e) {
        if (e.cancelable) e.preventDefault();
        state.pointer.active = true;
        if (typeof arena.setPointerCapture === "function") {
          try { arena.setPointerCapture(e.pointerId); } catch (_err) {}
        }
        onPointerMove(e);
      }

      function onPointerUp() {
        state.pointer.active = false;
      }

      function drawGrid(w, h) {
        ctx.fillStyle = "#f2f4f8";
        ctx.fillRect(0, 0, w, h);

        ctx.strokeStyle = "rgba(40, 52, 68, 0.08)";
        ctx.lineWidth = 1;

        const gap = 28;
        for (let x = 0; x <= w; x += gap) {
          ctx.beginPath();
          ctx.moveTo(x + 0.5, 0);
          ctx.lineTo(x + 0.5, h);
          ctx.stroke();
        }
        for (let y = 0; y <= h; y += gap) {
          ctx.beginPath();
          ctx.moveTo(0, y + 0.5);
          ctx.lineTo(w, y + 0.5);
          ctx.stroke();
        }
      }

      function drawTrail() {
        const pts = state.samples;
        if (pts.length < 2) return;
        const max = 120;
        const start = Math.max(0, pts.length - max);

        ctx.beginPath();
        for (let i = start; i < pts.length; i++) {
          const p = pts[i];
          if (i === start) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.strokeStyle = "rgba(15, 118, 110, 0.4)";
        ctx.lineWidth = 1.7;
        ctx.stroke();
      }

      function drawTarget() {
        const t = state.target;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.radius + 4, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(15, 118, 110, 0.1)";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(15, 118, 110, 0.2)";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(t.x, t.y, t.radius, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(15, 118, 110, 0.95)";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function drawPointer() {
        if (!state.pointer.has) return;
        ctx.beginPath();
        ctx.arc(state.pointer.x, state.pointer.y, 4.5, 0, Math.PI * 2);
        ctx.fillStyle = "#0b1624";
        ctx.fill();
      }

      function drawScene() {
        const w = state.bounds.w;
        const h = state.bounds.h;
        drawGrid(w, h);
        drawTrail();
        drawTarget();
        drawPointer();
      }

      function tick(now) {
        if (state.phase !== "running") return;
        const t = now - state.startMs;
        state.elapsedMs = t;

        if (t >= CONFIG.durationMs) {
          finishRun();
          return;
        }

        if (!state.lastFrameMs) state.lastFrameMs = t;
        const dt = Math.max(0, t - state.lastFrameMs);
        state.lastFrameMs = t;

        if (t >= state.nextPerturbAt && t < CONFIG.durationMs - 900) {
          injectPerturbation(t);
          scheduleNextPerturb(t);
        }

        const tp = targetPositionAt(t);
        state.target.x = tp.x;
        state.target.y = tp.y;
        state.target.radius = tp.r;
        state.target.seg = tp.seg;

        let err = null;
        if (state.pointer.has) {
          err = Math.hypot(state.pointer.x - tp.x, state.pointer.y - tp.y);
          state.totalMs += dt;
          if (err <= tp.r) state.insideMs += dt;
        }

        state.frameSeries.push({ t, err, seg: tp.seg, tx: tp.x, ty: tp.y, r: tp.r });

        drawScene();
        updateHud();

        state.frameId = requestAnimationFrame(tick);
      }

      function updateHud() {
        const tSec = state.elapsedMs / 1000;
        hudTime.textContent = tSec.toFixed(1) + "s";
        hudPerturb.textContent = String(state.perturbations.length);

        const inside = state.totalMs > 0 ? (state.insideMs / state.totalMs) * 100 : 0;
        hudInside.textContent = inside.toFixed(0) + "%";

        const hz = estimateSampleHz();
        hudHz.textContent = hz.toFixed(0);

        progressFill.style.width = ((state.elapsedMs / CONFIG.durationMs) * 100).toFixed(2) + "%";
      }

      function estimateSampleHz() {
        const s = state.samples;
        if (s.length < 6) return 0;
        const from = Math.max(1, s.length - 40);
        const dts = [];
        for (let i = from; i < s.length; i++) {
          dts.push(s[i].t - s[i - 1].t);
        }
        const m = mean(dts);
        return m > 0 ? 1000 / m : 0;
      }

      function nearestAtOrBefore(series, t) {
        let out = null;
        for (let i = 0; i < series.length; i++) {
          if (series[i].t <= t) out = series[i];
          else break;
        }
        return out;
      }

      function nearestValue(series, t, key) {
        if (!series.length) return null;
        let best = series[0];
        let bestDiff = Math.abs(series[0].t - t);
        for (let i = 1; i < series.length; i++) {
          const d = Math.abs(series[i].t - t);
          if (d < bestDiff) {
            best = series[i];
            bestDiff = d;
          }
        }
        return best[key];
      }

      function analyzeCorrections() {
        const corrections = [];
        const s = state.samples;
        const f = state.frameSeries;

        for (const p of state.perturbations) {
          const base = nearestAtOrBefore(s, p.t);
          if (!base) {
            corrections.push({ id: p.id, latencyMs: null, gain: 0, submoves: 0, seg: p.seg });
            continue;
          }

          const ux = p.dx / Math.max(1e-6, p.mag);
          const uy = p.dy / Math.max(1e-6, p.mag);

          let latency = null;
          let lastAx = null;
          let signChanges = 0;

          for (const q of s) {
            if (q.t < p.t + 55) continue;
            if (q.t > p.t + 900) break;
            const dispProj = ((q.x - base.x) * ux) + ((q.y - base.y) * uy);
            const velProj = (q.vx * ux) + (q.vy * uy);
            if (latency === null && dispProj > 3 && velProj > 25) {
              latency = q.t - p.t;
            }

            const accel = velProj;
            if (lastAx !== null) {
              const prevSign = Math.sign(lastAx);
              const nowSign = Math.sign(accel);
              if (prevSign !== 0 && nowSign !== 0 && prevSign !== nowSign) signChanges += 1;
            }
            lastAx = accel;
          }

          const e0 = nearestValue(f, p.t + 120, "err");
          let emin = Infinity;
          for (const row of f) {
            if (row.err === null) continue;
            if (row.t < p.t + 220 || row.t > p.t + 900) continue;
            if (row.err < emin) emin = row.err;
          }
          const gain = (Number.isFinite(e0) && Number.isFinite(emin)) ? (e0 - emin) / Math.max(1, e0) : 0;

          corrections.push({
            id: p.id,
            latencyMs: latency,
            gain,
            submoves: signChanges,
            seg: p.seg
          });
        }

        return corrections;
      }

      function countTeleports() {
        let count = 0;
        const s = state.samples;
        for (let i = 1; i < s.length; i++) {
          const dt = s[i].t - s[i - 1].t;
          const d = Math.hypot(s[i].x - s[i - 1].x, s[i].y - s[i - 1].y);
          if (dt < 18 && d > 50) count += 1;
        }
        return count;
      }

      function segmentStats() {
        const map = {
          low: { errors: [], speeds: [] },
          mid: { errors: [], speeds: [] },
          high: { errors: [], speeds: [] }
        };

        for (const row of state.frameSeries) {
          if (row.err !== null) map[row.seg].errors.push(row.err);
        }
        for (const s of state.samples) {
          const seg = currentDifficulty(s.t).label;
          if (Number.isFinite(s.speed)) map[seg].speeds.push(s.speed);
        }

        return {
          low: { e: mean(map.low.errors), v: mean(map.low.speeds) },
          mid: { e: mean(map.mid.errors), v: mean(map.mid.speeds) },
          high: { e: mean(map.high.errors), v: mean(map.high.speeds) }
        };
      }

      function scoreWindow(v, idealMin, idealMax, hardMin, hardMax) {
        if (!Number.isFinite(v)) return 0;
        if (v >= idealMin && v <= idealMax) return 1;
        if (v < hardMin || v > hardMax) return 0;
        if (v < idealMin) return (v - hardMin) / Math.max(1e-6, idealMin - hardMin);
        return (hardMax - v) / Math.max(1e-6, hardMax - idealMax);
      }

      function scoreRange(v, lo, hi) {
        if (!Number.isFinite(v)) return 0;
        if (v <= lo) return 0;
        if (v >= hi) return 1;
        return (v - lo) / (hi - lo);
      }

      function classify(score) {
        if (score >= 72) return { label: "Likely human", color: "var(--good)" };
        if (score >= 48) return { label: "Inconclusive", color: "var(--warn)" };
        return { label: "Likely automated", color: "var(--bad)" };
      }

      async function buildDigest(payload) {
        try {
          const data = new TextEncoder().encode(JSON.stringify(payload));
          const hash = await crypto.subtle.digest("SHA-256", data);
          const bytes = Array.from(new Uint8Array(hash));
          return bytes.map(b => b.toString(16).padStart(2, "0")).join("").slice(0, 24);
        } catch (_err) {
          return "unavailable";
        }
      }

      async function computeReport() {
        const corrections = analyzeCorrections();
        state.corrections = corrections;

        const validLat = corrections
          .map(c => c.latencyMs)
          .filter(v => Number.isFinite(v));

        const gains = corrections.map(c => c.gain).filter(v => Number.isFinite(v));
        const submoves = corrections.map(c => c.submoves).filter(v => Number.isFinite(v));

        const latencyHitRate = state.perturbations.length > 0 ? validLat.length / state.perturbations.length : 0;
        const latencyMedian = percentile(validLat, 0.5);
        const latencyIqr = percentile(validLat, 0.75) - percentile(validLat, 0.25);

        const gainMean = mean(gains);
        const subMedian = percentile(submoves, 0.5);

        const dwellRatio = state.totalMs > 0 ? (state.insideMs / state.totalMs) : 0;

        const seg = segmentStats();
        const speedMonotonic = (seg.high.v > seg.mid.v) && (seg.mid.v > seg.low.v * 0.85);
        const errorMonotonic = (seg.high.e >= seg.mid.e * 0.9) && (seg.mid.e >= seg.low.e * 0.85);
        const couplingScore = (speedMonotonic ? 0.6 : 0) + (errorMonotonic ? 0.4 : 0);

        const teleports = countTeleports();
        const ultraFast = validLat.filter(v => v < 75).length;

        const sLatencyRate = scoreRange(latencyHitRate, 0.30, 0.95);
        const sLatencyMedian = scoreWindow(latencyMedian, 120, 360, 80, 550);
        const sLatencySpread = scoreWindow(latencyIqr, 20, 190, 6, 280);
        const sGain = scoreRange(gainMean, 0.14, 0.74);
        const sDwell = scoreRange(dwellRatio, 0.24, 0.86);
        const sSubmoves = scoreWindow(subMedian, 1.0, 6.0, 0.0, 12.0);

        const rawScore = (
          (sLatencyRate * 25) +
          (sLatencyMedian * 20) +
          (sLatencySpread * 10) +
          (sGain * 15) +
          (sDwell * 10) +
          (couplingScore * 10) +
          (sSubmoves * 10)
        );

        const penalty = (teleports * 6) + (ultraFast * 8);
        const score = clamp(rawScore - penalty, 0, 100);

        const metrics = [
          {
            key: "Correction hit-rate",
            value: `${format(latencyHitRate * 100, 0)}%`,
            contrib: format(sLatencyRate * 25, 1),
            note: "How many perturbations produced a measurable causal correction"
          },
          {
            key: "Median correction latency",
            value: `${format(latencyMedian, 0)} ms`,
            contrib: format(sLatencyMedian * 20, 1),
            note: "Human online correction typically appears after sensory-motor delay"
          },
          {
            key: "Latency variability (IQR)",
            value: `${format(latencyIqr, 0)} ms`,
            contrib: format(sLatencySpread * 10, 1),
            note: "Too deterministic can indicate scripted behavior"
          },
          {
            key: "Error-reduction gain",
            value: format(gainMean, 2),
            contrib: format(sGain * 15, 1),
            note: "How strongly error shrinks after a perturbation"
          },
          {
            key: "In-target dwell",
            value: `${format(dwellRatio * 100, 0)}%`,
            contrib: format(sDwell * 10, 1),
            note: "Compliance and control stability"
          },
          {
            key: "Speed-accuracy coupling",
            value: format(couplingScore, 2),
            contrib: format(couplingScore * 10, 1),
            note: "Expected coupling when difficulty rises"
          },
          {
            key: "Submovement richness",
            value: format(subMedian, 1),
            contrib: format(sSubmoves * 10, 1),
            note: "Sign changes in correction dynamics"
          },
          {
            key: "Dynamic penalties",
            value: `${teleports} teleports, ${ultraFast} <75ms`,
            contrib: `-${format(penalty, 1)}`,
            note: "Impossible or near-impossible response artifacts"
          }
        ];

        const verdict = classify(score);

        const payloadForHash = {
          seed: state.seed,
          perturbations: state.perturbations,
          corrections,
          sampleCount: state.samples.length,
          frameCount: state.frameSeries.length,
          metrics,
          score
        };

        const challengeDigest = await buildDigest(payloadForHash);

        return {
          createdAt: new Date().toISOString(),
          config: CONFIG,
          seed: state.seed,
          digest: challengeDigest,
          score,
          verdict,
          metrics,
          summary: {
            durationMs: CONFIG.durationMs,
            sampleCount: state.samples.length,
            frameCount: state.frameSeries.length,
            perturbationCount: state.perturbations.length,
            correctionCount: validLat.length,
            meanSampleHz: estimateSampleHz(),
            segmentStats: seg
          },
          perturbations: state.perturbations,
          corrections,
          pointerSamples: state.samples
        };
      }

      function updateMetricsTable(metrics) {
        metricsBody.innerHTML = "";
        for (const m of metrics) {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>
              <div>${m.key}</div>
              <div class="small">${m.note}</div>
            </td>
            <td class="mono">${m.value}</td>
            <td class="mono">${m.contrib}</td>
          `;
          metricsBody.appendChild(tr);
        }
      }

      function updateLog(report) {
        const lines = [];
        lines.push(`digest=${report.digest}`);
        lines.push(`seed=${report.seed}`);
        lines.push(`score=${report.score.toFixed(1)} verdict=${report.verdict.label}`);
        if (report.serverVerification) {
          lines.push(`server=${report.serverVerification.mode} verified=${report.serverVerification.verified} reason=${report.serverVerification.reason}`);
        }
        lines.push(`perturbations=${report.summary.perturbationCount} corrections=${report.summary.correctionCount}`);
        lines.push("--- perturbation events ---");
        for (const p of report.perturbations) {
          lines.push(`p${p.id} t=${p.t.toFixed(0)}ms shift=(${p.dx.toFixed(1)}, ${p.dy.toFixed(1)}) seg=${p.seg}`);
        }
        eventLog.textContent = lines.join("\n");
      }

      async function finishRun() {
        state.phase = "analyzing";
        cancelAnimationFrame(state.frameId);
        state.frameId = 0;
        progressFill.style.width = "100%";
        statusLine.textContent = "analyzing";

        const report = await computeReport();
        const serverVerification = await verifyReportWithServer(report);
        report.challenge = state.challenge;
        report.serverVerification = serverVerification;
        state.finalReport = report;
        state.verification = serverVerification;

        scoreNum.textContent = report.score.toFixed(1);
        scoreNum.style.color = report.verdict.color;
        verdictLine.textContent = report.verdict.label;
        verdictLine.style.color = report.verdict.color;

        let verifyText = "local unsigned";
        if (serverVerification.mode === "server") {
          verifyText = serverVerification.verified ? "server verified" : `server reject (${serverVerification.reason})`;
        }
        summaryLine.textContent =
          `digest ${report.digest} | ${report.summary.perturbationCount} perturbations | ${report.summary.sampleCount} pointer samples | ${verifyText}`;

        if (serverVerification.mode === "server") {
          if (serverVerification.verified) {
            serverLine.textContent = `backend: verified challenge ${String(serverVerification.challengeId || "").slice(0, 8)}`;
          } else {
            serverLine.textContent = `backend: rejected (${serverVerification.reason})`;
          }
        } else {
          serverLine.textContent = "backend: local fallback (unsigned)";
        }

        updateMetricsTable(report.metrics);
        updateLog(report);

        statusLine.textContent = "done";
        state.phase = "done";
        exportBtn.disabled = false;
        startBtn.disabled = false;
      }

      async function startRun() {
        if (state.phase === "running") return;
        resetStateForRun();
        statusLine.textContent = "requesting challenge";
        startBtn.disabled = true;

        const challenge = await fetchChallenge();
        state.challenge = challenge;
        state.seed = challenge.seed;
        state.rng = mulberry32(state.seed);
        state.startMs = performance.now();
        state.phase = "running";
        state.lastFrameMs = 0;

        seedChip.textContent = `seed: ${state.seed}`;
        if (challenge.mode === "server") {
          serverLine.textContent = `backend: signed challenge ${String(challenge.id || "").slice(0, 8)}`;
        } else {
          serverLine.textContent = "backend: local fallback (unsigned)";
        }
        statusLine.textContent = "running";

        scheduleNextPerturb(0);
        state.frameId = requestAnimationFrame(tick);
      }

      function resetAll() {
        resetStateForRun();
        drawScene();
        startBtn.disabled = false;
      }

      function exportReport() {
        if (!state.finalReport) return;
        const blob = new Blob([JSON.stringify(state.finalReport, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `cpl-session-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      startBtn.addEventListener("click", startRun);
      resetBtn.addEventListener("click", resetAll);
      exportBtn.addEventListener("click", exportReport);

      arena.addEventListener("pointermove", onPointerMove, { passive: false });
      arena.addEventListener("pointerdown", onPointerDown, { passive: false });
      arena.addEventListener("pointerup", onPointerUp, { passive: true });
      arena.addEventListener("pointercancel", onPointerUp, { passive: true });
      arena.addEventListener("pointerleave", onPointerUp, { passive: true });

      if ("onpointerrawupdate" in window) {
        arena.addEventListener("pointerrawupdate", onPointerMove, { passive: false });
      }

      window.addEventListener("resize", () => {
        updateCanvasSize();
        drawScene();
      });

      updateCanvasSize();
      resetStateForRun();
      drawScene();
    })();
  </script>
</body>
</html>
